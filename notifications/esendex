#!/usr/bin/env python
# SMS via esendex.com
# -*- encoding: utf-8; py-indent-offset: 4 -*-

# (c) 2020 Nagarro Allgeier ES GmbH 
#          Mika Busch <mika.busch@allgeier-es.com>

# This is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# tails. You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.

import requests
import json
import os
import sys
import base64
import re
    
api_url = "https://api.esendex.com/v1.0/messagedispatcher"

def main():
    context = dict([ (var[7:], value.decode("utf-8"))
                      for (var, value) in os.environ.items()
                      if var.startswith("NOTIFY_")])

    if context['CONTACTPAGER'] == "":
        sys.stderr.write("Contact's pager address is empty, not sending anything.\n")
        return 2

    text = get_text(context)

    api_password = context["PARAMETER_API_PASSWORD"]
    user_name = context["PARAMETER_USER_NAME"]
    account_reference = context["PARAMETER_ACCOUNT_REFERENCE"]

    return send_sms(user_name, api_password, account_reference, text, context)

def get_text(context):
    max_len = 160
    message = context['HOSTNAME'] + " "

    notification_type = context["NOTIFICATIONTYPE"]

    # Prepare Default information and Type PROBLEM, RECOVERY
    if context['WHAT'] == 'SERVICE':
        if notification_type in [ "PROBLEM", "RECOVERY" ]:
            message += context['SERVICESHORTSTATE'] + " "
            message += context['SERVICEDESC'] + ": "
            rep = ["WARN - ", "CRIT - "]
            pattern = re.compile("|".join(rep))
            message += pattern.sub(lambda m: "", context['SERVICEOUTPUT'])           
        else:
            message += context['SERVICEDESC']
    else:
        if notification_type in [ "PROBLEM", "RECOVERY" ]:
            message += "is " + context['HOSTSTATE']
            message += "-" + context['HOSTOUTPUT']

    # Ouput the other State
    if notification_type.startswith("FLAP"):
        if "START" in notification_type:
            message += " Started Flapping"
        else:
            message += " Stopped Flapping"
    elif notification_type.startswith("DOWNTIME"):
        what = notification_type[8:].title()
        message += " Downtime " + what
        message += " " + context['NOTIFICATIONCOMMENT']
    elif notification_type == "ACKNOWLEDGEMENT":
        message += " Acknowledged"
        message += " " + context['NOTIFICATIONCOMMENT']
    elif notification_type == "CUSTOM":
        message += " Custom Notification"
        message += " " + context['NOTIFICATIONCOMMENT']
        
    return message if len(message) < max_len else message[:max_len]

def send_sms(user_name, api_password, account_reference, text, context):
    api_key = base64.b64encode(("{}:{}".format(user_name, api_password).encode()))
    headers = {'Authorization': 'Basic {}'.format(api_key.decode()), "Content-Type": "application/json", "Accept": "application/json"}
    data = {   
        "accountreference":account_reference,
        "messages":[{
            "to":context['CONTACTPAGER'].replace(" ", ""),
            "body":text
        }]
    }
    sys.stdout.write(u"Sending sms to {} with message: '{}'\n".format(
        context['CONTACTPAGER'].replace(" ", ""), 
        text.encode('ascii', 'ignore')))
    resp = requests.post(api_url, headers=headers, data=json.dumps(data))
    if resp.status_code == 200:
        sys.stdout.write("SMS sucessfully sent\n")
        return 0
    else:
        sys.stderr.write("Status Code: {}\n".format(resp.status_code))
        return 2
    return 0

sys.exit(main())
